name: Flatpak Release Pipeline

on:
  push:
    branches: [main, master]
    tags:
      - 'v*.*.*'           # Dispara para tags no formato v1.2.3
      - '!v*.*.*-rc*'      # Ignora release candidates
  workflow_dispatch:
    inputs:
      version:
        description: 'Versão específica (ex: v1.2.3)'
        required: true
        default: 'v0.0.0'

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  # Fase 1: Análise estática e linting
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgirepository1.0-dev \
            libgirepository-2.0-dev \
            make \
            gcc \
            libcairo2-dev \
            pkg-config \
            python3-dev \
            libglib2.0-dev \
            libxml2-dev \
            libxslt1-dev \
            libgtk-4-dev \
            libadwaita-1-dev \
            gir1.2-gtk-4.0 \
            gir1.2-adw-1 \
            libglib2.0-dev-bin

      - name: Install dependencies
        run: |
          pip install pre-commit
          pre-commit install
          pip install .[test]

      - name: Run static analysis
        run: pre-commit run --all-files

  # Fase 2: Versionamento semântico automático
  semantic:
    needs: analyze
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.version.outputs.changelog }}

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install semantic-release dependencies
        run: |
          npm install -g semantic-release @semantic-release/github @semantic-release/git @semantic-release/exec conventional-changelog-conventionalcommits

      - name: Run semantic-release dry-run to determine version
        id: version
        run: |
          # Executar o semantic-release em modo dry-run para determinar a próxima versão
          # A saída será usada para definir as variáveis de saída
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            # Usar semantic-release para determinar versão automaticamente
            VERSION=$(npx semantic-release --dry-run --no-ci | grep -o 'Published release [^[:space:]]*' | awk '{print $3}' | head -1)
            if [ -z "$VERSION" ]; then
              # Fallback se o semantic-release não encontrar uma versão
              # Analisar os commits para determinar o tipo de release
              LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
              COMMITS_SINCE_TAG=$(git log --oneline $LATEST_TAG..HEAD | wc -l)

              if [ "$COMMITS_SINCE_TAG" -eq 0 ]; then
                VERSION=$LATEST_TAG
              else
                # Analisar commits para determinar tipo de release
                if git log $LATEST_TAG..HEAD --oneline | grep -q "^\([0-9a-f]*\) \(feat\|fix\|breaking\|perf\|refactor\|style\|docs\|test\|build\|ci\|chore\|revert\)"; then
                  # Simular análise básica de commits
                  if git log $LATEST_TAG..HEAD --oneline | grep -qi "breaking"; then
                    # Major version increment
                    IFS='.' read -ra VER_PARTS <<< "${LATEST_TAG#v}"
                    MAJOR=$((VER_PARTS[0] + 1))
                    VERSION="v$MAJOR.0.0"
                  elif git log $LATEST_TAG..HEAD --oneline | grep -qi "feat"; then
                    # Minor version increment
                    IFS='.' read -ra VER_PARTS <<< "${LATEST_TAG#v}"
                    MINOR=$((VER_PARTS[1] + 1))
                    VERSION="v${VER_PARTS[0]}.$MINOR.0"
                  else
                    # Patch version increment
                    IFS='.' read -ra VER_PARTS <<< "${LATEST_TAG#v}"
                    PATCH=$((VER_PARTS[2] + 1))
                    VERSION="v${VER_PARTS[0]}.${VER_PARTS[1]}.$PATCH"
                  fi
                else
                  # Nenhuma mudança significativa, usar timestamp
                  VERSION="v${LATEST_TAG#v}-$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::7}"
                fi
              fi
            fi
          fi

          # Gerar changelog
          if [ -f CHANGELOG.md ]; then
            # Extrair apenas as seções relevantes do changelog, evitando caracteres especiais
            CHANGELOG=$(sed -n '/## \[Unreleased\]/,/## \[/p' CHANGELOG.md | head -n -1 | sed 's/"/\\"/g; s/\r$//g' | tr '\n' ' ' | sed 's/  */ /g' | head -c 500)
          else
            CHANGELOG="Release automático - $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          # Usar o método multilinha para definir o changelog de forma segura
          {
            echo "changelog<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "Version determined: $VERSION"
          echo "Changelog preview: $CHANGELOG"

      - name: Configure git for commits
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update version files and commit changes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          # Remover o prefixo 'v' se presente
          VERSION_CLEAN=${VERSION#v}

          # Atualizar arquivos com a nova versão
          make update-version-force v=$VERSION_CLEAN

          # Fazer commit das alterações
          git add .
          git commit -m "chore(release): atualiza versão para $VERSION [skip ci]" || echo "Nenhuma alteração para commit"

          # Fazer push das alterações
          git push origin HEAD:${{ github.ref_name }} || echo "Falha ao fazer push - talvez devido a proteção de branch"

  # Fase 3: Build apenas para x86_64
  build:
    needs: [analyze, semantic]
    runs-on: ubuntu-latest
    outputs:
      artifact_name: flatpak-${{ needs.semantic.outputs.version }}-x86_64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Update version file and related files with semantic version
        run: |
          VERSION="${{ needs.semantic.outputs.version }}"
          # Remover o prefixo 'v' se presente
          VERSION_CLEAN=${VERSION#v}
          make update-version-force v=$VERSION_CLEAN

      - name: Set artifact name
        id: set_artifact_name
        run: |
          VERSION="${{ needs.semantic.outputs.version }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Install Flatpak dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y flatpak \
          flatpak-builder \
          libgirepository1.0-dev \
          libgirepository-2.0-dev \
          make \
          gcc \
          libcairo2-dev \
          pkg-config \
          python3-dev \
          libglib2.0-dev \
          libxml2-dev \
          libxslt1-dev \
          libgtk-4-dev \
          libadwaita-1-dev \
          gir1.2-gtk-4.0 \
          gir1.2-adw-1 \
          libglib2.0-dev-bin
          pip install pytest pytest-cov

      - name: Add Flathub repository
        run: |
          flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

      - name: Install SDK and Platform
        run: |
          flatpak install -y --user flathub org.gnome.Platform//49 org.gnome.Sdk//49

      - name: Build Flatpak
        run: make flatpak
        env:
          FLATPAK_ARCH: x86_64

      - name: Upload build artifacts
        uses: actions/upload-artifact@v6
        with:
          name: flatpak-${{ needs.semantic.outputs.version }}-x86_64
          path: |
            build-dir/*.flatpak
            build-dir/*.json

  # Fase 4: Criar release no GitHub
  create-release:
    needs: [semantic, build]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Download build artifacts
        uses: actions/download-artifact@v6
        with:
          name: ${{ needs.build.outputs.artifact_name }}
          path: dist/x86_64

      - name: Get version from version file
        id: get_version
        run: |
          VERSION=$(cat version)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: Release v${{ steps.get_version.outputs.version }}
          body: ${{ needs.semantic.outputs.changelog }}
          files: |
            dist/x86_64/*.flatpak
            dist/x86_64/*.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Fase 5: Publicar no Flathub (requer permissão)
  publish-flathub:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    if: contains(github.ref, 'refs/tags/v') && !contains(github.ref, '-rc')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Flatpak Builder
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          manifest-path: io.github.mall0r.Twinverse.yaml

      - name: Submit to Flathub
        env:
          FLATHUB_TOKEN: ${{ secrets.FLATHUB_TOKEN }}
        run: |
          # Este passo requer configuração prévia no Flathub
