name: Flatpak Release Pipeline

on:
  push:
    branches: [main, master, build/workflow]
  workflow_dispatch:
    inputs:
      version:
        description: 'Versão específica (ex: v1.2.3)'
        required: true
        default: 'v0.0.0'

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  # Fase 1: Análise estática e linting
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgirepository1.0-dev \
            libgirepository-2.0-dev \
            make \
            gcc \
            libcairo2-dev \
            pkg-config \
            python3-dev \
            libglib2.0-dev \
            libxml2-dev \
            libxslt1-dev \
            libgtk-4-dev \
            libadwaita-1-dev \
            gir1.2-gtk-4.0 \
            gir1.2-adw-1 \
            libglib2.0-dev-bin

      - name: Install dependencies
        run: |
          pip install pre-commit
          pre-commit install
          pip install .[test]

      - name: Run static analysis
        run: pre-commit run --all-files

  # Fase 2: Versionamento semântico automático
  semantic:
    needs: analyze
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.version.outputs.changelog }}

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'


      - name: Install semantic-release dependencies
        run: |
          npm install --no-save semantic-release @semantic-release/github @semantic-release/git @semantic-release/exec conventional-changelog-conventionalcommits @semantic-release/commit-analyzer @semantic-release/release-notes-generator

      - name: Run semantic-release to determine version
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Criar um arquivo temporário para armazenar a saída
          TEMP_OUTPUT="/tmp/semantic_output.txt"

          # Executar o semantic-release em modo dry-run para determinar a próxima versão
          # Usando o .releaserc.json existente para manter a configuração
          npx semantic-release --dry-run --no-ci --debug > "$TEMP_OUTPUT" 2>&1 || true

          # Procurar por diferentes padrões na saída para encontrar a próxima versão
          VERSION=""

          # Procurar por padrões comuns na saída do semantic-release
          VERSION=$(grep -o 'next release [^[:space:]]*' "$TEMP_OUTPUT" | tail -1 | awk '{print $3}' | head -1)

          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o 'published release [^[:space:]]*' "$TEMP_OUTPUT" | tail -1 | awk '{print $3}' | head -1)
          fi

          if [ -z "$VERSION" ]; then
            VERSION=$(grep -o 'would publish release [^[:space:]]*' "$TEMP_OUTPUT" | tail -1 | awk '{print $4}' | head -1)
          fi

          if [ -z "$VERSION" ]; then
            # Se não encontrar na saída, tentar determinar com base no histórico de commits
            echo "Não foi possível determinar a versão com semantic-release, analisando commits manualmente..."

            # Tenta obter a última tag ou usar v1.0.0 como padrão para primeira release
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null)
            if [ $? -ne 0 ]; then
              # Primeira release - usar v1.0.0
              VERSION="v1.0.0"
            else
              # Já existe uma tag, analisar commits desde então
              echo "Analisando commits desde a última tag: $LATEST_TAG"

              # Verificar se há commits de breaking change (major)
              if git log $LATEST_TAG..HEAD --oneline --grep="BREAKING CHANGE\|breaking" > /dev/null 2>&1; then
                IFS='.' read -ra VER_PARTS <<< "${LATEST_TAG#v}"
                MAJOR=$((VER_PARTS[0] + 1))
                VERSION="v$MAJOR.0.0"
              # Verificar se há commits de feat (minor)
              elif git log $LATEST_TAG..HEAD --oneline --grep="^feat\|^Feat" > /dev/null 2>&1; then
                IFS='.' read -ra VER_PARTS <<< "${LATEST_TAG#v}"
                MINOR=$((VER_PARTS[1] + 1))
                VERSION="v${VER_PARTS[0]}.$MINOR.0"
              # Caso contrário, assumir patch
              else
                IFS='.' read -ra VER_PARTS <<< "${LATEST_TAG#v}"
                PATCH=$((VER_PARTS[2] + 1))
                VERSION="v${VER_PARTS[0]}.${VER_PARTS[1]}.$PATCH"
              fi
            fi
          fi

          # Gerar changelog
          if [ -f CHANGELOG.md ]; then
            # Extrair apenas as seções relevantes do changelog, evitando caracteres especiais
            CHANGELOG=$(sed -n '/## \[Unreleased\]/,/## \[/p' CHANGELOG.md | head -n -1 | sed 's/"/\\"/g; s/\r$//g' | tr '\n' ' ' | sed 's/  */ /g' | head -c 500)
          else
            CHANGELOG="Release automático - $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          # Usar o método multilinha para definir o changelog de forma segura
          {
            echo "changelog<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          # Também salvar versão e changelog como saídas para uso em outras etapas
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Version determined: $VERSION"
          echo "Changelog preview: $CHANGELOG"

          # Mostrar a saída completa para debug
          echo "=== Debug output from semantic-release ==="
          cat "$TEMP_OUTPUT"

      - name: Configure git for commits
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run semantic-release to execute full release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Executar o semantic-release para realizar o processo completo de release
          # Isso irá atualizar os arquivos, criar tags e fazer os commits conforme configurado no .releaserc.json
          npx semantic-release --no-ci --debug || echo "Semantic release completed or skipped"

  # Fase 3: Build apenas para x86_64
  build:
    needs: [analyze, semantic]
    runs-on: ubuntu-latest
    outputs:
      artifact_name: flatpak-${{ needs.semantic.outputs.version }}-x86_64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set artifact name
        id: set_artifact_name
        run: |
          VERSION="${{ needs.semantic.outputs.version }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Install Flatpak dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y flatpak \
          flatpak-builder \
          libgirepository1.0-dev \
          libgirepository-2.0-dev \
          make \
          gcc \
          libcairo2-dev \
          pkg-config \
          python3-dev \
          libglib2.0-dev \
          libxml2-dev \
          libxslt1-dev \
          libgtk-4-dev \
          libadwaita-1-dev \
          gir1.2-gtk-4.0 \
          gir1.2-adw-1 \
          libglib2.0-dev-bin
          pip install pytest pytest-cov

      - name: Add Flathub repository
        run: |
          flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

      - name: Install SDK and Platform
        run: |
          flatpak install -y --user flathub org.gnome.Platform//49 org.gnome.Sdk//49

      - name: Build Flatpak
        run: make flatpak
        env:
          FLATPAK_ARCH: x86_64

      - name: Upload build artifacts
        uses: actions/upload-artifact@v6
        with:
          name: flatpak-${{ needs.semantic.outputs.version }}-x86_64
          path: |
            build-dir/*.flatpak
            build-dir/*.json

  # Fase 4: Criar release no GitHub
  create-release:
    needs: [semantic, build]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Download build artifacts
        uses: actions/download-artifact@v6
        with:
          name: ${{ needs.build.outputs.artifact_name }}
          path: dist/x86_64

      - name: Get version from semantic step
        id: get_version
        run: |
          VERSION="${{ needs.semantic.outputs.version }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          body: ${{ needs.semantic.outputs.changelog }}
          files: |
            dist/x86_64/*.flatpak
            dist/x86_64/*.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Fase 5: Publicar no Flathub (requer permissão)
  publish-flathub:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    if: ${{ startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-rc') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Flatpak Builder
        uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          manifest-path: io.github.mall0r.Twinverse.yaml

      - name: Submit to Flathub
        env:
          FLATHUB_TOKEN: ${{ secrets.FLATHUB_TOKEN }}
        run: |
          # Este passo requer configuração prévia no Flathub
